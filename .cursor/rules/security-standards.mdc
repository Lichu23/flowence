---
description: Security standards and best practices for Flowence
globs: ["**/*.ts", "**/*.tsx", "server/**/*", "src/**/*"]
alwaysApply: true
---

# Security Standards for Flowence

## Authentication & Authorization
- Use JWT tokens with proper expiration (30 minutes)
- Implement refresh token mechanism
- Hash passwords with bcrypt (minimum 12 rounds)
- Implement role-based access control (RBAC)
- Use HTTPS in production
- Implement proper session management

## Password Security
```typescript
import bcrypt from 'bcrypt';

// Password hashing
export const hashPassword = async (password: string): Promise<string> => {
  const saltRounds = 12;
  return await bcrypt.hash(password, saltRounds);
};

// Password validation
export const validatePassword = async (password: string, hash: string): Promise<boolean> => {
  return await bcrypt.compare(password, hash);
};

// Password strength validation
export const validatePasswordStrength = (password: string): {
  isValid: boolean;
  errors: string[];
} => {
  const errors: string[] = [];
  
  if (password.length < 8) {
    errors.push('Password must be at least 8 characters long');
  }
  
  if (!/[A-Z]/.test(password)) {
    errors.push('Password must contain at least one uppercase letter');
  }
  
  if (!/[a-z]/.test(password)) {
    errors.push('Password must contain at least one lowercase letter');
  }
  
  if (!/\d/.test(password)) {
    errors.push('Password must contain at least one number');
  }
  
  if (!/[!@#$%^&*(),.?":{}|<>]/.test(password)) {
    errors.push('Password must contain at least one special character');
  }
  
  return {
    isValid: errors.length === 0,
    errors
  };
};
```

## JWT Token Management
```typescript
import jwt from 'jsonwebtoken';
import { User } from '../types';

const JWT_SECRET = process.env.JWT_SECRET!;
const JWT_EXPIRES_IN = '30m';
const REFRESH_TOKEN_EXPIRES_IN = '7d';

export interface TokenPayload {
  userId: string;
  email: string;
  role: string;
  storeId: string;
}

// Generate access token
export const generateAccessToken = (user: User): string => {
  const payload: TokenPayload = {
    userId: user.id,
    email: user.email,
    role: user.role,
    storeId: user.storeId
  };
  
  return jwt.sign(payload, JWT_SECRET, {
    expiresIn: JWT_EXPIRES_IN,
    issuer: 'flowence',
    audience: 'flowence-users'
  });
};

// Generate refresh token
export const generateRefreshToken = (user: User): string => {
  const payload = { userId: user.id, type: 'refresh' };
  
  return jwt.sign(payload, JWT_SECRET, {
    expiresIn: REFRESH_TOKEN_EXPIRES_IN,
    issuer: 'flowence',
    audience: 'flowence-users'
  });
};

// Verify token
export const verifyToken = (token: string): TokenPayload => {
  try {
    return jwt.verify(token, JWT_SECRET, {
      issuer: 'flowence',
      audience: 'flowence-users'
    }) as TokenPayload;
  } catch (error) {
    throw new Error('Invalid or expired token');
  }
};
```

## Input Validation & Sanitization
```typescript
import { body, validationResult } from 'express-validator';
import DOMPurify from 'dompurify';
import { JSDOM } from 'jsdom';

// Sanitize HTML input
export const sanitizeHtml = (input: string): string => {
  const window = new JSDOM('').window;
  const purify = DOMPurify(window as any);
  return purify.sanitize(input);
};

// Sanitize text input
export const sanitizeText = (input: string): string => {
  return input
    .trim()
    .replace(/[<>]/g, '') // Remove potential HTML tags
    .replace(/javascript:/gi, '') // Remove javascript: protocol
    .replace(/on\w+=/gi, ''); // Remove event handlers
};

// Validation middleware
export const validateInput = (req: Request, res: Response, next: NextFunction) => {
  const errors = validationResult(req);
  
  if (!errors.isEmpty()) {
    return res.status(400).json({
      success: false,
      error: {
        code: 'VALIDATION_ERROR',
        message: 'Invalid input data',
        details: errors.array().map(error => ({
          field: error.type === 'field' ? error.path : 'unknown',
          message: error.msg,
          value: error.type === 'field' ? error.value : undefined
        }))
      },
      timestamp: new Date().toISOString()
    });
  }
  
  next();
};

// Product validation rules
export const productValidationRules = [
  body('name')
    .trim()
    .isLength({ min: 1, max: 255 })
    .withMessage('Product name must be between 1 and 255 characters')
    .customSanitizer(sanitizeText),
  
  body('barcode')
    .optional()
    .trim()
    .isLength({ max: 255 })
    .withMessage('Barcode must be less than 255 characters')
    .customSanitizer(sanitizeText),
  
  body('price')
    .isFloat({ min: 0.01 })
    .withMessage('Price must be a positive number')
    .toFloat(),
  
  body('cost')
    .isFloat({ min: 0.01 })
    .withMessage('Cost must be a positive number')
    .toFloat(),
  
  body('stock')
    .isInt({ min: 0 })
    .withMessage('Stock must be a non-negative integer')
    .toInt(),
  
  body('category')
    .optional()
    .trim()
    .isLength({ max: 100 })
    .withMessage('Category must be less than 100 characters')
    .customSanitizer(sanitizeText),
  
  body('description')
    .optional()
    .trim()
    .isLength({ max: 1000 })
    .withMessage('Description must be less than 1000 characters')
    .customSanitizer(sanitizeHtml)
];
```

## SQL Injection Prevention
```typescript
import { Pool } from 'pg';

// Use parameterized queries
export class ProductRepository {
  private pool: Pool;
  
  // GOOD: Parameterized query
  async findById(id: string, storeId: string): Promise<Product | null> {
    const query = `
      SELECT * FROM products 
      WHERE id = $1 AND store_id = $2
    `;
    
    const result = await this.pool.query(query, [id, storeId]);
    return result.rows[0] || null;
  }
  
  // BAD: String concatenation (vulnerable to SQL injection)
  async findByIdBad(id: string, storeId: string): Promise<Product | null> {
    const query = `SELECT * FROM products WHERE id = '${id}' AND store_id = '${storeId}'`;
    const result = await this.pool.query(query);
    return result.rows[0] || null;
  }
}

// Validate and sanitize dynamic query parts
export const buildSearchQuery = (searchTerm: string, storeId: string): {
  query: string;
  params: string[];
} => {
  // Validate search term
  if (!searchTerm || typeof searchTerm !== 'string') {
    throw new Error('Invalid search term');
  }
  
  // Sanitize search term (remove special characters that could be used for injection)
  const sanitizedTerm = searchTerm.replace(/[^a-zA-Z0-9\s]/g, '');
  
  const query = `
    SELECT * FROM products 
    WHERE store_id = $1 
    AND (name ILIKE $2 OR barcode ILIKE $2)
    ORDER BY name ASC
  `;
  
  return {
    query,
    params: [storeId, `%${sanitizedTerm}%`]
  };
};
```

## XSS Prevention
```typescript
// React component with XSS prevention
import React from 'react';
import DOMPurify from 'dompurify';

interface ProductDescriptionProps {
  description: string;
}

const ProductDescription: React.FC<ProductDescriptionProps> = ({ description }) => {
  // Sanitize HTML content
  const sanitizedDescription = DOMPurify.sanitize(description, {
    ALLOWED_TAGS: ['p', 'br', 'strong', 'em', 'ul', 'ol', 'li'],
    ALLOWED_ATTR: []
  });
  
  return (
    <div 
      className="product-description"
      dangerouslySetInnerHTML={{ __html: sanitizedDescription }}
    />
  );
};

// Alternative: Use text content only
const SafeProductDescription: React.FC<ProductDescriptionProps> = ({ description }) => {
  // Strip all HTML tags
  const textOnly = description.replace(/<[^>]*>/g, '');
  
  return (
    <div className="product-description">
      {textOnly}
    </div>
  );
};
```

## CSRF Protection
```typescript
import csrf from 'csurf';

// CSRF protection middleware
export const csrfProtection = csrf({
  cookie: {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    sameSite: 'strict'
  }
});

// Custom CSRF token validation
export const validateCSRFToken = (req: Request, res: Response, next: NextFunction) => {
  const token = req.headers['x-csrf-token'] as string;
  const sessionToken = req.session?.csrfSecret;
  
  if (!token || !sessionToken || token !== sessionToken) {
    return res.status(403).json({
      success: false,
      error: {
        code: 'CSRF_TOKEN_INVALID',
        message: 'Invalid CSRF token'
      },
      timestamp: new Date().toISOString()
    });
  }
  
  next();
};
```

## Rate Limiting
```typescript
import rateLimit from 'express-rate-limit';

// General rate limiting
export const generalLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100, // Limit each IP to 100 requests per windowMs
  message: {
    success: false,
    error: {
      code: 'RATE_LIMIT_EXCEEDED',
      message: 'Too many requests from this IP, please try again later'
    },
    timestamp: new Date().toISOString()
  },
  standardHeaders: true,
  legacyHeaders: false
});

// Strict rate limiting for authentication
export const authLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 5, // Limit each IP to 5 login attempts per windowMs
  message: {
    success: false,
    error: {
      code: 'AUTH_RATE_LIMIT_EXCEEDED',
      message: 'Too many authentication attempts, please try again later'
    },
    timestamp: new Date().toISOString()
  },
  skipSuccessfulRequests: true
});

// API rate limiting
export const apiLimiter = rateLimit({
  windowMs: 60 * 1000, // 1 minute
  max: 60, // Limit each IP to 60 requests per minute
  message: {
    success: false,
    error: {
      code: 'API_RATE_LIMIT_EXCEEDED',
      message: 'API rate limit exceeded, please try again later'
    },
    timestamp: new Date().toISOString()
  }
});
```

## Security Headers
```typescript
import helmet from 'helmet';

// Security headers middleware
export const securityHeaders = helmet({
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      styleSrc: ["'self'", "'unsafe-inline'", "https://fonts.googleapis.com"],
      fontSrc: ["'self'", "https://fonts.gstatic.com"],
      imgSrc: ["'self'", "data:", "https:"],
      scriptSrc: ["'self'"],
      connectSrc: ["'self'"],
      frameSrc: ["'none'"],
      objectSrc: ["'none'"],
      upgradeInsecureRequests: []
    }
  },
  hsts: {
    maxAge: 31536000,
    includeSubDomains: true,
    preload: true
  },
  noSniff: true,
  xssFilter: true,
  referrerPolicy: { policy: 'strict-origin-when-cross-origin' }
});

// Custom security headers
export const customSecurityHeaders = (req: Request, res: Response, next: NextFunction) => {
  // Prevent clickjacking
  res.setHeader('X-Frame-Options', 'DENY');
  
  // Prevent MIME type sniffing
  res.setHeader('X-Content-Type-Options', 'nosniff');
  
  // XSS protection
  res.setHeader('X-XSS-Protection', '1; mode=block');
  
  // Referrer policy
  res.setHeader('Referrer-Policy', 'strict-origin-when-cross-origin');
  
  // Permissions policy
  res.setHeader('Permissions-Policy', 'camera=(), microphone=(), geolocation=()');
  
  next();
};
```

## Data Encryption
```typescript
import crypto from 'crypto';

const ENCRYPTION_KEY = process.env.ENCRYPTION_KEY!;
const ALGORITHM = 'aes-256-gcm';

// Encrypt sensitive data
export const encrypt = (text: string): string => {
  const iv = crypto.randomBytes(16);
  const cipher = crypto.createCipher(ALGORITHM, ENCRYPTION_KEY);
  cipher.setAAD(Buffer.from('flowence'));
  
  let encrypted = cipher.update(text, 'utf8', 'hex');
  encrypted += cipher.final('hex');
  
  const authTag = cipher.getAuthTag();
  
  return iv.toString('hex') + ':' + authTag.toString('hex') + ':' + encrypted;
};

// Decrypt sensitive data
export const decrypt = (encryptedText: string): string => {
  const textParts = encryptedText.split(':');
  const iv = Buffer.from(textParts.shift()!, 'hex');
  const authTag = Buffer.from(textParts.shift()!, 'hex');
  const encrypted = textParts.join(':');
  
  const decipher = crypto.createDecipher(ALGORITHM, ENCRYPTION_KEY);
  decipher.setAAD(Buffer.from('flowence'));
  decipher.setAuthTag(authTag);
  
  let decrypted = decipher.update(encrypted, 'hex', 'utf8');
  decrypted += decipher.final('utf8');
  
  return decrypted;
};
```

## Audit Logging
```typescript
import winston from 'winston';

// Security event logger
export const securityLogger = winston.createLogger({
  level: 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.json()
  ),
  transports: [
    new winston.transports.File({ filename: 'logs/security.log' }),
    new winston.transports.Console()
  ]
});

// Log security events
export const logSecurityEvent = (event: {
  type: 'LOGIN_ATTEMPT' | 'LOGIN_SUCCESS' | 'LOGIN_FAILURE' | 'UNAUTHORIZED_ACCESS' | 'DATA_ACCESS' | 'DATA_MODIFICATION';
  userId?: string;
  ip: string;
  userAgent: string;
  details?: any;
}) => {
  securityLogger.info({
    ...event,
    timestamp: new Date().toISOString()
  });
};

// Authentication logging middleware
export const authLogging = (req: Request, res: Response, next: NextFunction) => {
  const originalSend = res.send;
  
  res.send = function(data) {
    // Log authentication events
    if (req.path.includes('/auth/login')) {
      if (res.statusCode === 200) {
        logSecurityEvent({
          type: 'LOGIN_SUCCESS',
          userId: req.user?.id,
          ip: req.ip,
          userAgent: req.get('User-Agent') || 'Unknown'
        });
      } else {
        logSecurityEvent({
          type: 'LOGIN_FAILURE',
          ip: req.ip,
          userAgent: req.get('User-Agent') || 'Unknown',
          details: { statusCode: res.statusCode }
        });
      }
    }
    
    return originalSend.call(this, data);
  };
  
  next();
};
```

## Environment Security
```typescript
// Environment variable validation
export const validateEnvironment = (): void => {
  const requiredVars = [
    'JWT_SECRET',
    'DB_HOST',
    'DB_NAME',
    'DB_USER',
    'DB_PASSWORD',
    'STRIPE_SECRET_KEY',
    'SENDGRID_API_KEY'
  ];
  
  const missingVars = requiredVars.filter(varName => !process.env[varName]);
  
  if (missingVars.length > 0) {
    throw new Error(`Missing required environment variables: ${missingVars.join(', ')}`);
  }
  
  // Validate JWT secret strength
  if (process.env.JWT_SECRET!.length < 32) {
    throw new Error('JWT_SECRET must be at least 32 characters long');
  }
  
  // Validate database connection string
  if (process.env.NODE_ENV === 'production' && !process.env.DATABASE_URL?.includes('ssl=true')) {
    throw new Error('Production database connection must use SSL');
  }
};
```

## Best Practices
- Never store sensitive data in plain text
- Use environment variables for secrets
- Implement proper error handling without exposing sensitive information
- Use HTTPS in production
- Implement proper logging and monitoring
- Regular security audits and penetration testing
- Keep dependencies updated
- Use secure coding practices
- Implement proper session management
- Use least privilege principle
- Implement proper input validation
- Use prepared statements for database queries
- Implement proper error handling
- Use security headers
- Implement rate limiting
- Use proper authentication and authorization
- Implement audit logging
- Use encryption for sensitive data
- Implement proper backup and recovery procedures